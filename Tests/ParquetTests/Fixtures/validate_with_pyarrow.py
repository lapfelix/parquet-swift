#!/usr/bin/env python3
"""
PyArrow validation script for parquet-swift writer.

Reads Parquet files generated by parquet-swift and validates them with PyArrow
to confirm cross-implementation compatibility.
"""

import sys
from pathlib import Path
import pyarrow.parquet as pq


def validate_lists(file_path):
    """Validate single-level list file."""
    print("\n" + "=" * 60)
    print(f"Validating: {file_path.name}")
    print("=" * 60)

    table = pq.read_table(file_path)

    # Expected data
    expected_rows = 5
    expected_lists = [
        [1, 2, 3],          # Row 0: normal list
        None,               # Row 1: NULL list
        [],                 # Row 2: empty list
        [42],               # Row 3: single element
        [10, 20, 30, 40]    # Row 4: larger list
    ]

    # Verify row count
    if len(table) != expected_rows:
        print(f"❌ Row count mismatch: expected {expected_rows}, got {len(table)}")
        return False

    # Verify column name
    if table.column_names != ['numbers']:
        print(f"❌ Column name mismatch: expected ['numbers'], got {table.column_names}")
        return False

    # Read column
    numbers_col = table['numbers']

    # Verify each row
    for i, expected in enumerate(expected_lists):
        actual = numbers_col[i].as_py()
        if actual != expected:
            print(f"❌ Row {i} mismatch: expected {expected}, got {actual}")
            return False

    print("✓ All rows match expected values")
    print(f"✓ Schema: {table.schema}")
    return True


def validate_nested_lists(file_path):
    """Validate nested list file."""
    print("\n" + "=" * 60)
    print(f"Validating: {file_path.name}")
    print("=" * 60)

    table = pq.read_table(file_path)

    # Expected data
    expected_rows = 4
    expected_lists = [
        [[1, 2], [3]],      # Row 0: normal nested
        None,               # Row 1: NULL outer
        [None],             # Row 2: NULL inner
        [[]]                # Row 3: empty inner
    ]

    # Verify row count
    if len(table) != expected_rows:
        print(f"❌ Row count mismatch: expected {expected_rows}, got {len(table)}")
        return False

    # Verify column name
    if table.column_names != ['matrix']:
        print(f"❌ Column name mismatch: expected ['matrix'], got {table.column_names}")
        return False

    # Read column
    matrix_col = table['matrix']

    # Verify each row
    for i, expected in enumerate(expected_lists):
        actual = matrix_col[i].as_py()
        if actual != expected:
            print(f"❌ Row {i} mismatch: expected {expected}, got {actual}")
            return False

    print("✓ All rows match expected values")
    print(f"✓ Schema: {table.schema}")
    return True


def validate_maps(file_path):
    """Validate map file."""
    print("\n" + "=" * 60)
    print(f"Validating: {file_path.name}")
    print("=" * 60)

    table = pq.read_table(file_path)

    # Expected data (PyArrow represents maps as list of structs)
    expected_rows = 4
    expected_maps = [
        [('a', 1), ('b', 2), ('c', 3)],  # Row 0: normal map (sorted keys)
        None,                             # Row 1: NULL map
        [],                               # Row 2: empty map
        [('x', 100)]                      # Row 3: single entry
    ]

    # Verify row count
    if len(table) != expected_rows:
        print(f"❌ Row count mismatch: expected {expected_rows}, got {len(table)}")
        return False

    # Verify column name
    if table.column_names != ['properties']:
        print(f"❌ Column name mismatch: expected ['properties'], got {table.column_names}")
        return False

    # Read column
    properties_col = table['properties']

    # Verify each row
    for i, expected in enumerate(expected_maps):
        actual = properties_col[i].as_py()

        # PyArrow returns tuples directly
        if actual is not None:
            actual_tuples = sorted(actual)
        else:
            actual_tuples = None

        if actual_tuples != expected:
            print(f"❌ Row {i} mismatch:")
            print(f"   Expected: {expected}")
            print(f"   Got:      {actual_tuples}")
            return False

    print("✓ All rows match expected values")
    print(f"✓ Schema: {table.schema}")
    return True


def validate_structs(file_path):
    """Validate struct file."""
    print("\n" + "=" * 60)
    print(f"Validating: {file_path.name}")
    print("=" * 60)

    table = pq.read_table(file_path)

    # Expected data
    expected_rows = 4
    expected_names = ["Alice", "Bob", None, "Charlie"]
    expected_ages = [30, None, 25, 35]

    # Verify row count
    if len(table) != expected_rows:
        print(f"❌ Row count mismatch: expected {expected_rows}, got {len(table)}")
        return False

    # Verify column names
    if table.column_names != ['name', 'age']:
        print(f"❌ Column names mismatch: expected ['name', 'age'], got {table.column_names}")
        return False

    # Read columns
    name_col = table['name'].to_pylist()
    age_col = table['age'].to_pylist()

    # Verify names
    if name_col != expected_names:
        print(f"❌ Name column mismatch: expected {expected_names}, got {name_col}")
        return False

    # Verify ages
    if age_col != expected_ages:
        print(f"❌ Age column mismatch: expected {expected_ages}, got {age_col}")
        return False

    print("✓ All rows match expected values")
    print(f"✓ Schema: {table.schema}")
    return True


def main():
    """Main validation routine."""
    if len(sys.argv) != 2:
        print("Usage: validate_with_pyarrow.py <validation-directory>")
        print("Example: validate_with_pyarrow.py /tmp/parquet-validation")
        sys.exit(1)

    validation_dir = Path(sys.argv[1])

    if not validation_dir.exists():
        print(f"❌ Directory not found: {validation_dir}")
        sys.exit(1)

    print("PyArrow Cross-Implementation Validation")
    print("=" * 60)
    print(f"Validation directory: {validation_dir}")

    # Track results
    results = []

    # Validate each file type
    files = {
        'lists.parquet': validate_lists,
        'nested_lists.parquet': validate_nested_lists,
        'maps.parquet': validate_maps,
        'structs.parquet': validate_structs
    }

    for filename, validator in files.items():
        file_path = validation_dir / filename
        if not file_path.exists():
            print(f"\n❌ File not found: {filename}")
            results.append(False)
            continue

        try:
            success = validator(file_path)
            results.append(success)
        except Exception as e:
            print(f"\n❌ Error validating {filename}: {e}")
            import traceback
            traceback.print_exc()
            results.append(False)

    # Print summary
    print("\n" + "=" * 60)
    print("VALIDATION SUMMARY")
    print("=" * 60)

    passed = sum(results)
    total = len(results)

    for filename, success in zip(files.keys(), results):
        status = "✓ PASS" if success else "❌ FAIL"
        print(f"{status}: {filename}")

    print("-" * 60)
    print(f"Result: {passed}/{total} files validated successfully")

    if passed == total:
        print("\n✓ All validation tests passed!")
        print("✓ Cross-implementation compatibility confirmed with PyArrow")
        sys.exit(0)
    else:
        print("\n❌ Some validation tests failed")
        sys.exit(1)


if __name__ == '__main__':
    main()
